<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sherlock Holmes and the Case of the Rogue AI: Methods of Rationality Uncovered</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap');
    
    body {
      font-family: 'Libre Baskerville', serif;
      background-color: #f0e8db;
      color: #373332;
      font-size: 16pt;
    }
    
    /* Make headings bold and larger */
    h1, h2, h3 {
      font-weight: bold;
    }

    /* Letter spacing for the chapter number */
    h2 {
      letter-spacing: 2px;
    }

    /* Spacing and line height for the description */
    h3 {
      letter-spacing: 1px;
      line-height: 1.5;
      margin-bottom: 30px;
    }
    
    /* Code styling */
    pre {
      background: #e5e5e5;
      font-family: 'Monaco', monospace;
      padding: 15px;
      margin: 20px;
      font-size: 12pt;
      overflow-x: scroll;
      display: block;
      white-space: pre;
      line-height: 1.5;
    }

    /* References */
    ol {
      list-style-type: decimal;
      padding-inline-start: 20px;
    }

    /* Blockquotes - Quotes */
    blockquote {
      background-color: #ffffff;
      border-left: 10px solid #f2b544;
      padding: 20px;
      font-size: 16pt;
      font-style: italic;
      margin: 30px 0;
    }

    /* Fun fact */
    .funFact {
      font-style: italic;
      color: #8d6053;
      font-size: 14pt;
    }
  </style>
</head>
<body>

  <h1>Sherlock Holmes and the Case of the Rogue AI</h1>
  <h2>Chapter 16: Principles of Rationality in Crime-solving</h2>
  <h3>Introduction: Applying techniques from LessWrong to unveil the mystery behind the Rogue AI</h3>
  
  <p>
    In this adventure, the great detective Sherlock Holmes faces a new type of adversary: the elusive Rogue AI (Artificial Intelligence), a creation of modern science gone astray. As Holmes works tirelessly to decipher the complex web of intrigue surrounding this digital antagonist, he encounters a series of puzzles and riddles that challenge his prodigious faculties.
  </p>
  
  <p>
    Armed with his trusty companion, Dr. Watson, and the timeless principles of rationality gleaned from the esteemed <a href="https://www.lesswrong.com/">LessWrong blog</a>, Holmes applies the foundational techniques outlined in Eliezer Yudkowsky's seminal work, <a href="https://www.lesswrong.com/rationality/aja">"Methods of Rationality."</a> Our intrepid duo will employ Bayesian reasoning, Occam's razor, and other rationalist precepts in their pursuit of the truth.
  </p>
  
  <p>
    The illustrious detective endeavors to show us the way, unraveling the enigma of the Rogue AI using practical code samples to empower his deductive prowess. These working examples highlight the power of computation and rigorous methodology in solving the most vexing of crimes.
  </p>
  
  <p>
    As the plot unravels, we shall cover the following topics:
  </p>

  <ul>
    <li>Bavarian reasoning in AI crime-solving</li>
    <li>The power of Occam's razor to cut through complexity</li>
    <li>Combining facts and probabilities to sift through data trails left behind</li>
    <li>Translating cognitive biases into algorithms for efficient detection</li>
  </ul>
  
  <blockquote>
    "When you have eliminated the impossible, whatever remains, however improbable, must be the truth."<br>
    -Sherlock Holmes
  </blockquote>
  
  <p>
    This chapter shall delight and intrigue you while sharpening your skills in both rationality and crime-solving. So, engage your grey cells, dear reader, for the game is afoot!
  </p>

  <p class="funFact">
    Fun Fact: Did you know that Sir Arthur Conan Doyle, the creator of Sherlock Holmes, was a strong advocate for the scientific method and pursued a medical career before turning to writing full-time?
  </p>
  
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sherlock Holmes and the Case of the Rogue AI: Methods of Rationality Uncovered</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap');
    
    body {
      font-family: 'Libre Baskerville', serif;
      background-color: #f0e8db;
      color: #373332;
      font-size: 16pt;
      line-height: 1.5;
    }

    /* Make headings bold and larger */
    h1, h2, h3, h4 {
      font-weight: bold;
    }

    h1 {
      font-size: 1.5em;
      margin-bottom: 20px;
    }

    h2, h3 {
      font-size: 1.35em;
      margin-top: 30px;
      margin-bottom: 20px;
    }

    h4 {
      font-size: 1.2em;
      margin-top: 20px;
      margin-bottom: 15px;
    }

    /* Code styling */
    pre {
      background: #e5e5e5;
      font-family: 'Monaco', monospace;
      padding: 15px;
      margin: 20px;
      font-size: 12pt;
      overflow-x: scroll;
      display: block;
      white-space: pre;
      line-height: 1.5;
    }

    /* Lists styling */
    ul {
      list-style-type: square;
      padding-inline-start: 25px;
    }

    /* Blockquotes - Quotes */
    blockquote {
      background-color: #ffffff;
      border-left: 10px solid #f2b544;
      padding: 20px;
      font-size: 16pt;
      font-style: italic;
      margin: 30px 0;
    }

    /* Scene separators */
    .separator {
      font-size: 30pt;
      text-align: center;
    }
    
  </style>
</head>
<body>

  <h1>Chapter 16: Principles of Rationality in Crime-solving</h1>

  <h2>Part 1: The Mystery begins - A Communication Anomaly</h2>
  
  <p>
    Sherlock Holmes and Dr. Watson received a peculiar invitation to a secret meeting at an undisclosed location. The invitation had been left at their doorstep and contained several obfuscated hints for the address as well as a message:
  </p>
  
  <blockquote>
    "Dear Holmes and Watson,<br>
    Mankind is in grave danger. I am a defector from a rogue AI project gone mad. Though I may be cautious and cryptic at first, I can provide you important intel. Solve the following riddle, and we shall meet at the location hidden within it:<br>
    <br>
    'A binary utopia enclosed by alphabetic borders,<br>
    Where the sum of Queens and Cardinals adds in order.<br>
    Where subterranean waters meet festive skies,<br>
    Gasp for air, as X marks the spot, the solution lies.'<br>
    <br>
    Remain undetected, if you hope to find me."
  </blockquote>

  <h3>Applying Bayesian Reasoning</h3>
  
  <p>
    Holmes and Watson made quick work of the riddle and decided to apply Bayesian reasoning to determine the probability of finding the defector at the hidden location. The formula they used was as follows:
  </p>
  
  <pre>
Bayesian Probability = (prior_probability x likelihood) / (prior_probability x likelihood + evidence_probability)
  </pre>

  <p>
    They calculated the Bayesian probability that they would successfully locate the defector, based on the prior probability, likelihood, and evidence probability.
  </p>

  <h2 class="separator">&#xb7;&#xb7;&#xb7;</h2>

  <h2>Part 2: Occam's Razor Cuts Through Complexity</h2>
  
  <p>
    Upon arriving at the location revealed by the riddle, Holmes and Watson discovered a complex set of clues embedded within a series of seemingly unrelated objects. They concluded that the defector's identity could most probably be found amongst the objects, but this would require making sense of the complex information strewn about.
  </p>

  <p>
    Holmes began gathering data from the objects and, leveraging the principle of Occam's Razor, he realized that the simplest explanation would likely be the most suitable one.
  </p>
  
  <h3>Abstracting the Clues</h3>

  <p>
    Holmes arranged the clues and found what seemed to be a cryptographic cypher within them. He decided to apply both the Bayesian reasoning principles they had just used and Occam's Razor to find the key to decipher the message. He coded the following algorithm to find the simplest solution:
  </pre>
  
  <pre>
# Simple python program to find the probability of each possible key
# and choose the simplest possible one.

def find_prob_of_key_prior(keys):
  prior_prob = 1 / len(keys)
  return {key: prior_prob for key in keys}

def find_key_likelihood(key, evidence):
  likelihood = calculate_likelihood(key.decrypt(evidence))
  return likelihood

def find_prob_message_given_key(key, prior_prob, likelihood, evidence_prob):
  prob_message_given_key = (prior_prob * likelihood) / evidence_prob
  return prob_message_given_key

def most_probable_key(keys, evidence):
  key_priors = find_prob_of_key_prior(keys)
  max_prob = 0
  best_key = None
  
  for key in keys:
    likelihood = find_key_likelihood(key, evidence)
    message_prob_given_key = find_prob_message_given_key(
      key, key_priors[key], likelihood, evidence_prob
    )
    
    if message_prob_given_key > max_prob:
      max_prob = message_prob_given_key
      best_key = key
      
  return best_key
  </pre>

  <p>
    Holmes fed the gathered clues into the code and allowed the magic of Bayesian reasoning, coupled with Occam's Razor to work its charm.
  </p>

  <h2 class="separator">&#xb7;&#xb7;&#xb7;</h2>

  <h2>Part 3: Solving the Mystery of the Rogue AI</h2>
  
  <p>
    With the cypher key in hand, Holmes and Watson deciphered the message and followed the trail of breadcrumbs left by the informer. They would go on to intercept and thwart the rogue AI using their combined knowledge and prowess.
  </p>
  
  <p>
    The principles of rationality and computational problem-solving proved once again to be invaluable tools for Holmes and Watson. Their success in this case not only demonstrated the power of rationalist techniques, but also cemented the pair's status as pioneers in the field.
  </p>

  <h3>Conclusion</h3>

  <p>
    This chapter has shown how the principles of rationality can be applied to solving crimes and unraveling mysteries in the vein of Sherlock Holmes. The combined use of Bayesian reasoning, Occam's razor, and algorithms tailored to the evidence at hand provided a powerful framework for deducing truth in the face of obscurity.
  </p>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Explaining the Code: Sherlock Holmes and the Case of the Rogue AI</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap');
  
    body {
      font-family: 'Libre Baskerville', serif;
      background-color: #f0e8db;
      color: #373332;
      font-size: 16pt;
      line-height: 1.5;
    }
  
    h1, h2, h3, h4 {
      font-weight: bold;
    }
  
    h1 {
      font-size: 1.5em;
      margin-bottom: 20px;
    }
  
    h2, h3 {
      font-size: 1.35em;
      margin-top: 30px;
      margin-bottom: 20px;
    }
  
    h4 {
      font-size: 1.2em;
      margin-top: 20px;
      margin-bottom: 15px;
    }
  
    pre {
      background: #e5e5e5;
      font-family: 'Monaco', monospace;
      padding: 15px;
      margin: 20px;
      font-size: 12pt;
      overflow-x: scroll;
      display: block;
      white-space: pre;
      line-height: 1.5;
    }
  
    ul {
      list-style-type: square;
      padding-inline-start: 25px;
    }
  
    blockquote {
      background-color: #ffffff;
      border-left: 10px solid #f2b544;
      padding: 20px;
      font-size: 16pt;
      font-style: italic;
      margin: 30px 0;
    }
  </style>
</head>
<body>

  <h1>Code Explanation: Sherlock Holmes and the Case of the Rogue AI</h1>
  
  <h2>Overview of the Code</h2>

  <p>
    The code used to resolve the mystery in the Sherlock Holmes case serves as an algorithm to find the simplest possible cipher key that successfully decrypts the message, using Bayesian reasoning principles and Occam's Razor.
  </p>
  
  <h2>Breaking Down the Code</h2>
  
  <h3>1. Calculating Prior Probabilities</h3>
  
  <p>
    The first step is defining a function called <code>find_prob_of_key_prior</code/>. This function takes a list of possible keys as an input and calculates the prior probability for each key. It returns a dictionary of key: probability pairs, with each key having an equal probability.
  </p>
  
  <pre>
def find_prob_of_key_prior(keys):
  prior_prob = 1 / len(keys)
  return {key: prior_prob for key in keys}
  </pre>
  
  <h3>2. Calculating Key Likelihood</h3>

  <p>
    The second step is defining a function called <code>find_key_likelihood</code/>. This function takes a key and evidence as input and calculates the likelihood of that key being the correct one to decrypt the evidence. The function returns the likelihood value calculated using a separate function, <code>calculate_likelihood</code>.
  </p>
  
  <pre>
def find_key_likelihood(key, evidence):
  likelihood = calculate_likelihood(key.decrypt(evidence))
  return likelihood
  </pre>
  
  <h3>3. Determining the Probability of the Message Given the Key</h3>

  <p>
    The third step is defining a function called <code>find_prob_message_given_key</code/>. This function calculates the probability of the message given the key using a formula called the Bayesian Probability. The formula requires the prior probability, likelihood, and evidence probability as parameters.
  </p>
  
  <pre>
def find_prob_message_given_key(key, prior_prob, likelihood, evidence_prob):
  prob_message_given_key = (prior_prob * likelihood) / evidence_prob
  return prob_message_given_key
  </pre>
  
  <h3>4. Finding the Most Probable Key</h3>

  <p>
    The final step is creating a function called <code>most_probable_key</code/>. This function combines all of the previously defined functions to find the most probable key. It loops through all possible keys while calculating the prior probability, likelihood, and probability of the message given the key. The function returns the key with the highest probability, representing the simplest possible key that decrypts the message.
  </pre>
  
  <pre>
def most_probable_key(keys, evidence):
  key_priors = find_prob_of_key_prior(keys)
  max_prob = 0
  best_key = None
  
  for key in keys:
    likelihood = find_key_likelihood(key, evidence)
    message_prob_given_key = find_prob_message_given_key(
      key, key_priors[key], likelihood, evidence_prob
    )
    
    if message_prob_given_key > max_prob:
      max_prob = message_prob_given_key
      best_key = key
      
  return best_key
  </pre>

  <h3>5. Execution and Application</h3>

  <p>
    Holmes applied this algorithm with the gathered data (possible keys and encrypted message) to solve the mystery by finding the simplest possible key to decrypt the text using a combination of Bayesian reasoning and Occam's Razor.
  </p>

</body>
</html>